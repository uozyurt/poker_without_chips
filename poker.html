<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline Poker Helper - Realistic Table</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Open+Sans:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Open Sans', sans-serif;
            background-color: #1a202c; /* Darker gray-blue */
            color: #e2e8f0; /* Lighter gray for text */
            overflow: hidden; /* Prevent scrollbars from table layout */
        }
        .player-card {
            transition: all 0.3s ease;
            border: 3px solid #4a5568; /* Gray-600 */
            background-color: #2d3748; /* Gray-800 */
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            width: 160px; /* Fixed width */
            min-height: 110px; /* Fixed min-height */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .current-player {
            border-color: #63b3ed; /* Brighter Blue-400 */
            box-shadow: 0 0 25px rgba(99, 179, 237, 0.8), 0 0 10px rgba(99, 179, 237, 0.6) inset;
            transform: scale(1.08);
            z-index: 10;
        }
        .folded-player {
            opacity: 0.5;
            background-color: #4a5568 !important;
            border-color: #2d3748 !important;
        }
        .action-button {
            transition: all 0.2s ease;
            font-family: 'Roboto', sans-serif;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .action-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .action-button:active {
            transform: translateY(0px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .dealer-chip::before { content: 'D'; display: inline-block; width: 22px; height: 22px; line-height: 22px; text-align: center; background-color: #fefcbf; color: #744210; border-radius: 50%; font-weight: bold; margin-right: 6px; border: 1px solid #d69e2e; font-size: 0.8rem;}
        .sb-chip::before { content: 'SB'; display: inline-block; width: 22px; height: 22px; line-height: 22px; text-align: center; background-color: #68d391; color: #276749; border-radius: 50%; font-size: 0.65rem; font-weight: bold; margin-right: 6px; border: 1px solid #38a169;}
        .bb-chip::before { content: 'BB'; display: inline-block; width: 22px; height: 22px; line-height: 22px; text-align: center; background-color: #63b3ed; color: #2c5282; border-radius: 50%; font-size: 0.65rem; font-weight: bold; margin-right: 6px; border: 1px solid #3182ce;}

        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7); display: flex;
            justify-content: center; align-items: center; z-index: 1000;
        }
        .modal-content { background-color: #2d3748; padding: 25px; border-radius: 10px; box-shadow: 0 10px 25px rgba(0,0,0,0.5); width: 90%; max-width: 450px; }
        .hidden { display: none !important; }

        /* Poker Table Layout */
        #game-board {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex; /* Using flex for main layout, though children are mostly absolute */
            flex-direction: column;
            align-items: center;
            justify-content: center; /* This centers the absolute children's reference point */
            padding-top: 70px; /* Space for top controls */
            padding-bottom: 220px; /* Increased space for bottom controls and message area */
            box-sizing: border-box;
        }
        #poker-table-visual {
            position: absolute;
            width: 75vw;
            max-width: 1000px;
            height: 55vh;
            max-height: 500px;
            background: radial-gradient(ellipse at center, #38a169 0%, #2f855a 60%, #276749 100%);
            border-radius: 120px / 70px; /* Elliptical border */
            border: 15px solid #875A31; /* Wooden border */
            box-shadow: inset 0 0 25px rgba(0,0,0,0.6), 0 15px 35px rgba(0,0,0,0.5), 0 0 0 5px #533519; /* Inner shadow, outer shadow, outer rim */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }
        #poker-table-visual::before { /* Inner betting line */
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: calc(100% - 80px);
            height: calc(100% - 60px);
            border: 2px dashed rgba(255, 255, 200, 0.3);
            border-radius: 90px / 50px; /* Match parent's elliptical nature */
            transform: translate(-50%, -50%);
        }

        #players-ring-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90vw; /* Responsive width */
            max-width: 1200px; /* Max width for large screens */
            height: 70vh; /* Responsive height, potentially adjusted by JS or specific needs */
            max-height: 650px; /* Max height for large screens */
            z-index: 5;
            pointer-events: none; /* Container itself doesn't catch clicks */
        }
        #players-ring-container .player-card {
            pointer-events: all; /* Player cards should be interactive */
            position: absolute; /* Positioned by JavaScript */
        }

        #game-controls-top {
            position: absolute;
            top: 15px; /* Positioned at the top */
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            display: flex;
            gap: 15px;
            background-color: rgba(26, 32, 44, 0.9); /* Semi-transparent background */
            padding: 12px 25px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        /* Community cards container - centered on the table */
        #community-cards-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 6; /* Above table, below players if they overlap center */
            display: flex;
            gap: 10px;
            padding: 10px; /* Padding around cards */
            border-radius: 8px;
        }
        .community-card {
            width: 60px;
            height: 90px;
            background-color: #4A5568; /* Default card back color */
            border: 2px solid #2D3748;
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem; /* For card value text */
            font-weight: bold;
            color: #A0AEC0; /* Placeholder text color */
            box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
            transition: all 0.5s ease;
            transform-style: preserve-3d; /* For potential flip animation */
        }
        .community-card.revealed {
            background-color: #CBD5E0; /* Revealed card face color */
            border-color: #A0AEC0;
            color: #4A5568; /* Revealed card text color */
        }
         .community-card.revealed::before { /* Placeholder for actual card value, JS should fill this */
            content: "?";
            font-size: 3rem;
            color: #718096;
            text-shadow: 0 0 5px rgba(0,0,0,0.2);
        }
        /* Removed old #game-controls-bottom and #action-prompt specific styles here, handled by new structure and Tailwind */
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center justify-center p-0">

    <div id="setup-section" class="w-full max-w-md bg-gray-800 p-8 rounded-xl shadow-2xl m-auto">
        <h1 class="text-4xl font-bold mb-8 text-center text-blue-400 font-roboto">Poker Game Setup</h1>
        <div class="space-y-5">
            <div>
                <label for="player-count" class="block text-sm font-medium text-gray-300">Number of Players (2-10):</label>
                <input type="number" id="player-count" min="2" max="10" value="4" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-lg shadow-sm py-2.5 px-4 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-white">
            </div>
            <div>
                <label for="entry-amount" class="block text-sm font-medium text-gray-300">Starting Chips per Player:</label>
                <input type="number" id="entry-amount" value="1000" step="100" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-lg shadow-sm py-2.5 px-4 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-white">
            </div>
            <div>
                <label for="small-blind" class="block text-sm font-medium text-gray-300">Small Blind:</label>
                <input type="number" id="small-blind" value="10" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-lg shadow-sm py-2.5 px-4 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-white">
            </div>
            <div>
                <label for="big-blind" class="block text-sm font-medium text-gray-300">Big Blind:</label>
                <input type="number" id="big-blind" value="20" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-lg shadow-sm py-2.5 px-4 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-white">
            </div>
        </div>
        <button id="to-player-names-btn" class="mt-10 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3.5 px-4 rounded-lg action-button">Next: Player Names</button>
    </div>

    <div id="player-names-section" class="hidden w-full max-w-md bg-gray-800 p-8 rounded-xl shadow-2xl m-auto">
        <h2 class="text-3xl font-bold mb-8 text-center text-blue-400 font-roboto">Enter Player Names</h2>
        <div id="player-name-inputs" class="space-y-4"></div>
        <button id="start-game-btn" class="mt-8 w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3.5 px-4 rounded-lg action-button">Start Game</button>
        <button id="back-to-setup-btn" class="mt-4 w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg action-button">Back to Setup</button>
    </div>

    <div id="game-board" class="hidden">
        <div id="poker-table-visual"></div>
        <div id="community-cards-container">
            <div class="community-card" id="comm-card-1"></div>
            <div class="community-card" id="comm-card-2"></div>
            <div class="community-card" id="comm-card-3"></div>
            <div class="community-card" id="comm-card-4"></div>
            <div class="community-card" id="comm-card-5"></div>
        </div>

        <div id="game-controls-top">
            <div id="game-info" class="flex gap-x-6 items-center text-sm">
                <p>Pot: <span id="pot-display" class="font-bold text-yellow-300 text-base">0</span></p>
                <p>Bet: <span id="current-bet-display" class="font-bold text-orange-400 text-base">0</span></p>
                <p>Phase: <span id="game-phase-display" class="font-bold text-cyan-400 text-base"></span></p>
                <p>Dealer: <span id="dealer-display" class="font-bold text-gray-300"></span></p>
            </div>
             <button id="manual-edit-toggle-btn" class="action-button bg-purple-600 hover:bg-purple-700 text-white text-xs py-2 px-3 rounded-md">Edit Stacks</button>
             <button id="undo-btn" class="action-button bg-yellow-500 hover:bg-yellow-600 text-gray-900 text-xs py-2 px-3 rounded-md">Undo (U)</button>
        </div>

        <div id="players-ring-container">
            </div>

        <div id="game-controls-bottom-wrapper" class="absolute bottom-2 left-1/2 transform -translate-x-1/2 w-11/12 md:w-4/5 max-w-3xl z-20 flex flex-col gap-2">
            <div id="actions-and-prompt-container" class="bg-gray-800/90 backdrop-blur-sm p-3 rounded-xl shadow-xl flex flex-col md:flex-row items-center gap-3">
                <div class="w-full md:w-1/3">
                    <p id="action-prompt" class="text-xs sm:text-sm text-center md:text-left text-yellow-300 font-roboto leading-tight">
                        Player X's turn. Stack: Y. To Call: Z. Min Addtl Raise: W.
                    </p>
                </div>

                <div class="w-full md:w-2/3 flex flex-col sm:flex-row gap-2 justify-center">
                    <button id="fold-btn" class="action-button bg-red-600 hover:bg-red-700 text-white font-bold py-2.5 px-3 sm:px-4 rounded-lg flex-grow text-xs sm:text-sm">Fold (F)</button>
                    <button id="call-check-btn" class="action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-2.5 px-3 sm:px-4 rounded-lg flex-grow text-xs sm:text-sm">Call/Check (C)</button>
                    <div class="flex flex-grow gap-2 items-center">
                        <input type="number" id="raise-amount-input" placeholder="Raise BY" class="bg-gray-700 border-gray-600 rounded-lg py-2.5 px-2 text-white focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent flex-grow min-w-0 text-center text-xs sm:text-sm">
                        <button id="raise-btn" class="action-button bg-green-500 hover:bg-green-600 text-white font-bold py-2.5 px-3 sm:px-4 rounded-lg text-xs sm:text-sm">Raise</button>
                    </div>
                </div>
            </div>

            <div id="message-area" class="w-full bg-gray-700/80 backdrop-blur-sm p-2.5 rounded-lg text-center text-sm min-h-[40px] text-green-300 font-roboto">
                Welcome to Poker Night!
            </div>
        </div>
        </div>

    <div id="winner-selection-modal" class="modal hidden">
        <div class="modal-content bg-gray-800 p-6 rounded-lg shadow-xl text-white">
            <h3 class="text-2xl font-bold mb-4 text-center text-blue-400 font-roboto">Showdown! Who Won?</h3>
            <p class="text-center mb-4">Click on the player who won the hand.</p>
            <div id="winner-options-container" class="space-y-2">
                </div>
            <button id="cancel-winner-selection-btn" class="mt-4 w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md action-button">Cancel</button>
        </div>
    </div>


<script>
    // --- DOM Elements ---
    const setupSection = document.getElementById('setup-section');
    const playerCountInput = document.getElementById('player-count');
    const entryAmountInput = document.getElementById('entry-amount');
    const smallBlindInput = document.getElementById('small-blind');
    const bigBlindInput = document.getElementById('big-blind');
    const toPlayerNamesBtn = document.getElementById('to-player-names-btn');

    const playerNamesSection = document.getElementById('player-names-section');
    const playerNameInputsContainer = document.getElementById('player-name-inputs');
    const startGameBtn = document.getElementById('start-game-btn');
    const backToSetupBtn = document.getElementById('back-to-setup-btn');

    const gameBoard = document.getElementById('game-board');
    const potDisplay = document.getElementById('pot-display');
    const currentBetDisplay = document.getElementById('current-bet-display');
    const gamePhaseDisplay = document.getElementById('game-phase-display');
    const dealerDisplay = document.getElementById('dealer-display');
    const playersRingContainer = document.getElementById('players-ring-container');
    const actionPrompt = document.getElementById('action-prompt'); // Still used, but now within the new structure
    const foldBtn = document.getElementById('fold-btn');
    const callCheckBtn = document.getElementById('call-check-btn');
    const raiseAmountInput = document.getElementById('raise-amount-input');
    const raiseBtn = document.getElementById('raise-btn');
    const messageArea = document.getElementById('message-area'); // Still used
    const undoBtn = document.getElementById('undo-btn');
    const manualEditToggleBtn = document.getElementById('manual-edit-toggle-btn');

    const winnerSelectionModal = document.getElementById('winner-selection-modal');
    const winnerOptionsContainer = document.getElementById('winner-options-container');
    const cancelWinnerSelectionBtn = document.getElementById('cancel-winner-selection-btn');

    const communityCardElements = [
        document.getElementById('comm-card-1'),
        document.getElementById('comm-card-2'),
        document.getElementById('comm-card-3'),
        document.getElementById('comm-card-4'),
        document.getElementById('comm-card-5'),
    ];

    // --- Game State Variables ---
    let players = [];
    let pot = 0;
    let smallBlindValue = 0;
    let bigBlindValue = 0;
    let currentPlayerIndex = 0;
    let dealerIndex = -1;
    let gamePhase = '';
    let communityCardsRevealed = [false, false, false, false, false];

    let currentBetForStreet = 0;
    let minAdditionalRaise = 0;
    let lastRaiseAmount = 0;

    let actionHistory = [];
    const MAX_UNDO_HISTORY = 20;
    let manualEditMode = false;


    // --- Utility Functions ---
    function deepClone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }

    function saveStateForUndo() {
        const state = {
            players: deepClone(players),
            pot, smallBlindValue, bigBlindValue, currentPlayerIndex, dealerIndex, gamePhase,
            communityCardsRevealed: [...communityCardsRevealed],
            currentBetForStreet, minAdditionalRaise, lastRaiseAmount,
            message: messageArea.textContent,
            actionPrompt: actionPrompt.textContent,
            callCheckBtnText: callCheckBtn.textContent,
            raiseAmountInputVal: raiseAmountInput.value
        };
        actionHistory.push(state);
        if (actionHistory.length > MAX_UNDO_HISTORY) actionHistory.shift();
        undoBtn.disabled = actionHistory.length <= 1;
    }

    function loadStateFromUndo() {
        if (actionHistory.length <= 1) {
            showMessage("Nothing more to undo."); return;
        }
        actionHistory.pop();
        const prevState = actionHistory[actionHistory.length - 1];

        players = deepClone(prevState.players);
        pot = prevState.pot; smallBlindValue = prevState.smallBlindValue; bigBlindValue = prevState.bigBlindValue;
        currentPlayerIndex = prevState.currentPlayerIndex; dealerIndex = prevState.dealerIndex; gamePhase = prevState.gamePhase;
        communityCardsRevealed = [...prevState.communityCardsRevealed];
        currentBetForStreet = prevState.currentBetForStreet;
        minAdditionalRaise = prevState.minAdditionalRaise;
        lastRaiseAmount = prevState.lastRaiseAmount;

        messageArea.textContent = prevState.message;
        actionPrompt.textContent = prevState.actionPrompt;
        callCheckBtn.textContent = prevState.callCheckBtnText;
        raiseAmountInput.value = prevState.raiseAmountInputVal || '';

        updateUI();
        undoBtn.disabled = actionHistory.length <= 1;
    }

    // --- UI Update Functions ---
    function updatePlayerPositions() {
        const numTablePlayers = players.length;
        if (numTablePlayers === 0) return;

        const containerWidth = playersRingContainer.offsetWidth;
        const containerHeight = playersRingContainer.offsetHeight;

        const radiusX = (containerWidth / 2) * 0.82;
        // MODIFIED: Reduced vertical radius factor to make player ring flatter
        const radiusY = (containerHeight / 2) * 0.70; // Was 0.78

        const centerX = containerWidth / 2;
        const centerY = containerHeight / 2;
        const playerCardWidth = 160;
        const playerCardHeight = 110;

        document.querySelectorAll('.player-card').forEach((card, index) => {
            const angleOffset = Math.PI / 2; // Player 0 at the bottom
            const angle = angleOffset + (index / numTablePlayers) * 2 * Math.PI;

            let x = centerX + radiusX * Math.cos(angle) - (playerCardWidth / 2);
            let y = centerY + radiusY * Math.sin(angle) - (playerCardHeight / 2);

            card.style.left = `${x}px`;
            card.style.top = `${y}px`;
        });
    }


    function updateUI() {
        potDisplay.textContent = pot;
        currentBetDisplay.textContent = currentBetForStreet;
        gamePhaseDisplay.textContent = gamePhase.charAt(0).toUpperCase() + gamePhase.slice(1);
        dealerDisplay.textContent = dealerIndex !== -1 && players[dealerIndex] ? players[dealerIndex].name : 'N/A';

        communityCardElements.forEach((cardEl, index) => {
            cardEl.classList.toggle('revealed', communityCardsRevealed[index]);
        });

        playersRingContainer.innerHTML = '';
        players.forEach((player, index) => {
            const playerDiv = document.createElement('div');
            playerDiv.className = `player-card p-3 rounded-lg shadow-md border-2 ${player.folded ? 'folded-player' : ''} ${index === currentPlayerIndex && gamePhase !== 'roundEnd' && gamePhase !== 'showdown' && gamePhase !== 'gameOver' ? 'current-player' : 'border-gray-600'}`;
            playerDiv.dataset.playerId = index;

            let indicators = '';
            if (index === dealerIndex) indicators += '<span class="dealer-chip" title="Dealer"></span>';

            const activePlayerIndices = players.map((p, i) => p.stack > 0 ? i : -1).filter(i => i !== -1);
            let sbPlayerIndex = -1, bbPlayerIndex = -1;

            if (activePlayerIndices.length >= 2) {
                let currentDealerIndexInActive = activePlayerIndices.indexOf(dealerIndex);
                if (currentDealerIndexInActive === -1 && activePlayerIndices.length > 0) currentDealerIndexInActive = 0;

                if (activePlayerIndices.length === 2) {
                    sbPlayerIndex = activePlayerIndices[currentDealerIndexInActive % activePlayerIndices.length];
                    bbPlayerIndex = activePlayerIndices[(currentDealerIndexInActive + 1) % activePlayerIndices.length];
                } else {
                    sbPlayerIndex = activePlayerIndices[(currentDealerIndexInActive + 1) % activePlayerIndices.length];
                    bbPlayerIndex = activePlayerIndices[(currentDealerIndexInActive + 2) % activePlayerIndices.length];
                }
            }

            if (index === sbPlayerIndex && (gamePhase === 'preflop' || gamePhase === 'roundEnd')) indicators += '<span class="sb-chip" title="Small Blind"></span>';
            if (index === bbPlayerIndex && (gamePhase === 'preflop' || gamePhase === 'roundEnd')) indicators += '<span class="bb-chip" title="Big Blind"></span>';

            let betInfo = '';
            if (player.betThisStreet > 0) {
                betInfo = `<p class="text-xs text-yellow-300 mt-1">Bet: ${player.betThisStreet}</p>`;
            }
            if (player.isAllIn) {
                betInfo += `<p class="text-xs text-red-400 font-bold">ALL-IN</p>`;
            }

            playerDiv.innerHTML = `
                <div>
                    <h3 class="text-base font-semibold truncate ${player.folded ? 'text-gray-400' : 'text-blue-300'} font-roboto">${indicators}${player.name}</h3>
                    <div class="flex items-center mt-1">
                        <p class="text-lg ${player.stack === 0 ? 'text-red-400' : 'text-green-300'} font-roboto">${player.stack}</p>
                        ${manualEditMode ? `<input type="number" value="${player.stack}" class="manual-stack-edit ml-2 w-16 bg-gray-600 text-white p-0.5 rounded text-xs" data-player-index="${index}">` : ''}
                    </div>
                    ${betInfo}
                </div>
                ${player.folded ? '<p class="text-xs text-red-300 mt-1 self-start">FOLDED</p>' : ''}
            `;
            if (gamePhase === 'showdown' && !player.folded) {
                const winnerButton = document.createElement('button');
                winnerButton.textContent = 'WINNER';
                winnerButton.className = 'mt-1 w-full bg-green-500 hover:bg-green-600 text-white py-0.5 px-1 rounded text-xs action-button self-end';
                winnerButton.onclick = () => handleWinnerSelection(index);
                playerDiv.appendChild(winnerButton);
            }
            playersRingContainer.appendChild(playerDiv);
        });

        updatePlayerPositions();

        if (manualEditMode) {
            document.querySelectorAll('.manual-stack-edit').forEach(input => {
                input.addEventListener('change', (e) => {
                    const pIndex = parseInt(e.target.dataset.playerIndex);
                    const newStack = parseInt(e.target.value);
                    if (!isNaN(newStack) && newStack >= 0) {
                        players[pIndex].stack = newStack;
                        saveStateForUndo();
                        updateUI();
                    } else {
                        e.target.value = players[pIndex].stack;
                    }
                });
            });
        }
        
        // Get the container for actions and prompt (this ID is new)
        const actionsAndPromptContainer = document.getElementById('actions-and-prompt-container');

        if (gamePhase !== 'roundEnd' && gamePhase !== 'showdown' && gamePhase !== 'gameOver' && players.length > 0 && players[currentPlayerIndex]) {
            const currentP = players[currentPlayerIndex];
            const amountToCallVal = Math.max(0, currentBetForStreet - currentP.betThisStreet);
            // Update action prompt text
            actionPrompt.textContent = `${currentP.name}'s turn. Stack: ${currentP.stack}. To Call: ${amountToCallVal}. Min Addtl Raise: ${minAdditionalRaise}`;

            callCheckBtn.textContent = amountToCallVal > 0 ? `Call ${amountToCallVal} (C)` : 'Check (C)';

            foldBtn.disabled = currentP.folded || currentP.isAllIn;
            callCheckBtn.disabled = currentP.folded || currentP.isAllIn;

            const canAffordToCall = currentP.stack >= amountToCallVal;
            const canMakeAnyRaise = currentP.stack > amountToCallVal;

            raiseBtn.disabled = currentP.folded || currentP.isAllIn || !canMakeAnyRaise;
            raiseAmountInput.disabled = currentP.folded || currentP.isAllIn || !canMakeAnyRaise;

            raiseAmountInput.min = minAdditionalRaise;
            raiseAmountInput.placeholder = `Raise BY (min ${minAdditionalRaise})`;
            if (actionsAndPromptContainer) actionsAndPromptContainer.classList.remove('hidden');
        } else {
            actionPrompt.textContent = '---';
            foldBtn.disabled = true; callCheckBtn.disabled = true; raiseBtn.disabled = true; raiseAmountInput.disabled = true;
            if (actionsAndPromptContainer) actionsAndPromptContainer.classList.add('hidden');
        }
    }

    function showMessage(msg, isError = false) {
        messageArea.textContent = msg;
        messageArea.className = `w-full bg-gray-700/80 backdrop-blur-sm p-2.5 rounded-lg text-center text-sm min-h-[40px] font-roboto ${isError ? 'text-red-300' : 'text-green-300'}`;
    }

    // --- Game Flow & Logic ---
    function initializePlayerNamesInputs() {
        const count = parseInt(playerCountInput.value);
        playerNameInputsContainer.innerHTML = '';
        for (let i = 0; i < count; i++) {
            const div = document.createElement('div');
            div.className = "flex flex-col";
            div.innerHTML = `
                <label for="player-name-${i}" class="text-sm font-medium text-gray-300 mb-1">Player ${i + 1} Name:</label>
                <input type="text" id="player-name-${i}" value="Player ${i+1}" class="block w-full bg-gray-700 border-gray-600 rounded-lg shadow-sm py-2 px-3 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-white">
            `;
            playerNameInputsContainer.appendChild(div);
        }
    }

    entryAmountInput.addEventListener('input', () => {
        const entry = parseInt(entryAmountInput.value);
        if (entry > 0) {
            smallBlindInput.value = Math.max(1, Math.floor(entry / 100));
            bigBlindInput.value = Math.max(1, Math.floor(entry / 50));
        }
    });

    toPlayerNamesBtn.addEventListener('click', () => {
        const pCount = parseInt(playerCountInput.value);
        if (pCount >=2 && pCount <=10) {
            setupSection.classList.add('hidden');
            playerNamesSection.classList.remove('hidden');
            initializePlayerNamesInputs();
            document.getElementById('player-name-0').focus();
        } else {
            showMessage("Player count must be between 2 and 10.", true); // Using showMessage for consistency
        }
    });

    backToSetupBtn.addEventListener('click', () => {
        playerNamesSection.classList.add('hidden');
        setupSection.classList.remove('hidden');
    });

    startGameBtn.addEventListener('click', () => {
        const numPlayers = parseInt(playerCountInput.value);
        const startChips = parseInt(entryAmountInput.value);
        smallBlindValue = parseInt(smallBlindInput.value);
        bigBlindValue = parseInt(bigBlindInput.value);

        if (isNaN(startChips) || startChips <= 0 || isNaN(smallBlindValue) || smallBlindValue <= 0 || isNaN(bigBlindValue) || bigBlindValue <= 0) {
            showMessage("Please enter valid chip amounts and blinds.", true); return;
        }
        if (smallBlindValue >= bigBlindValue) {
            showMessage("Small blind must be less than big blind.", true); return;
        }

        players = [];
        for (let i = 0; i < numPlayers; i++) {
            const nameInput = document.getElementById(`player-name-${i}`);
            if (!nameInput || nameInput.value.trim() === '') {
                showMessage(`Please enter a name for Player ${i + 1}.`, true); return;
            }
            players.push({
                name: nameInput.value.trim(), stack: startChips,
                betThisStreet: 0, folded: false, isAllIn: false, hasActedThisCycle: false,
            });
        }

        playerNamesSection.classList.add('hidden');
        gameBoard.classList.remove('hidden');
        gameBoard.classList.add('flex');
        dealerIndex = numPlayers > 0 ? Math.floor(Math.random() * numPlayers) : -1;
        actionHistory = [];
        saveStateForUndo();
        startNewRound();
        window.addEventListener('resize', updatePlayerPositions);
    });

    function startNewRound() {
        gamePhase = 'preflop';
        pot = 0;
        currentBetForStreet = 0;
        communityCardsRevealed = [false, false, false, false, false];

        const activeChipPlayers = players.filter(p => p.stack > 0);
        if (activeChipPlayers.length < 2) {
            endGame(); return;
        }

        let potentialDealer = dealerIndex;
        do {
            potentialDealer = (potentialDealer + 1) % players.length;
        } while (players[potentialDealer].stack === 0);
        dealerIndex = potentialDealer;

        players.forEach(p => {
            p.betThisStreet = 0;
            p.folded = p.stack === 0;
            p.isAllIn = p.stack === 0 && !p.folded;
            p.hasActedThisCycle = false;
        });

        let sbIndex, bbIndex;
        const activePlayerIndices = players.map((p, i) => p.stack > 0 ? i : -1).filter(i => i !== -1);

        let currentDealerActualIndex = dealerIndex;
        let dealerPosInActive = activePlayerIndices.indexOf(currentDealerActualIndex);
        if(dealerPosInActive === -1 && activePlayerIndices.length > 0) dealerPosInActive = 0;

        if (activePlayerIndices.length === 2) {
            sbIndex = activePlayerIndices[dealerPosInActive % activePlayerIndices.length];
            bbIndex = activePlayerIndices[(dealerPosInActive + 1) % activePlayerIndices.length];
        } else {
            sbIndex = activePlayerIndices[(dealerPosInActive + 1) % activePlayerIndices.length];
            bbIndex = activePlayerIndices[(dealerPosInActive + 2) % activePlayerIndices.length];
        }

        if (players[sbIndex] && players[sbIndex].stack > 0) {
            const sbAmount = Math.min(players[sbIndex].stack, smallBlindValue);
            players[sbIndex].stack -= sbAmount; players[sbIndex].betThisStreet = sbAmount; pot += sbAmount;
            if(players[sbIndex].stack === 0) players[sbIndex].isAllIn = true;
        }
        if (players[bbIndex] && players[bbIndex].stack > 0) {
            const bbAmount = Math.min(players[bbIndex].stack, bigBlindValue);
            players[bbIndex].stack -= bbAmount; players[bbIndex].betThisStreet = bbAmount; pot += bbAmount;
            if(players[bbIndex].stack === 0) players[bbIndex].isAllIn = true;
        }

        currentBetForStreet = bigBlindValue;
        minAdditionalRaise = bigBlindValue;
        lastRaiseAmount = bigBlindValue;

        if (activePlayerIndices.length === 2) {
            currentPlayerIndex = sbIndex;
        } else {
            let utgIndexCandidate = (bbIndex + 1) % players.length;
            while(players[utgIndexCandidate].stack === 0 || players[utgIndexCandidate].folded) {
                utgIndexCandidate = (utgIndexCandidate + 1) % players.length;
                if (utgIndexCandidate === (bbIndex + 1) % players.length && (players[utgIndexCandidate].stack === 0 || players[utgIndexCandidate].folded)) break;
            }
            currentPlayerIndex = utgIndexCandidate;
        }
        let initialCpi = currentPlayerIndex;
        while(players[currentPlayerIndex].folded || players[currentPlayerIndex].isAllIn) {
             currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
             if (currentPlayerIndex === initialCpi) break;
        }

        players.forEach(p => p.hasActedThisCycle = false);

        showMessage(`New round! ${players[sbIndex]?.name || 'SB'} posts ${smallBlindValue}, ${players[bbIndex]?.name || 'BB'} posts ${bigBlindValue}.`);
        saveStateForUndo();
        updateUI();
    }

    function getActivePlayers() {
        return players.filter(p => !p.folded);
    }

    function getPotentiallyActivePlayers() {
        return players.filter(p => !p.folded && !p.isAllIn);
    }


    function handleAction(action, additionalAmount = 0) {
        if (gamePhase === 'roundEnd' || gamePhase === 'showdown' || gamePhase === 'gameOver') return;
        const player = players[currentPlayerIndex];
        if (!player || player.folded || player.isAllIn) return;

        saveStateForUndo();
        let actionTakenMessage = `${player.name} `;
        player.hasActedThisCycle = true;

        if (action === 'fold') {
            player.folded = true;
            actionTakenMessage += "folds.";
        } else if (action === 'call-check') {
            const amountToCall = Math.max(0, currentBetForStreet - player.betThisStreet);
            if (amountToCall === 0) {
                actionTakenMessage += "checks.";
            } else {
                const callValue = Math.min(player.stack, amountToCall);
                player.stack -= callValue;
                player.betThisStreet += callValue;
                pot += callValue;
                actionTakenMessage += `calls ${callValue}.`;
                if (player.stack === 0) { player.isAllIn = true; actionTakenMessage += " (ALL-IN!)"; }
            }
        } else if (action === 'raise') {
            const amountToCall = Math.max(0, currentBetForStreet - player.betThisStreet);
            const totalChipsForThisAction = amountToCall + additionalAmount;

            if (additionalAmount < minAdditionalRaise && player.stack > totalChipsForThisAction) {
                 showMessage(`Invalid raise. Min additional raise is ${minAdditionalRaise}. You tried to add ${additionalAmount}.`, true);
                 actionHistory.pop(); return;
            }
            if (additionalAmount <= 0 && player.stack > totalChipsForThisAction) {
                 showMessage(`Additional raise amount must be positive.`, true);
                 actionHistory.pop(); return;
            }

            let actualAdditionalRaiseAmount = additionalAmount;
            if (totalChipsForThisAction > player.stack) { // All-in raise
                actualAdditionalRaiseAmount = player.stack - amountToCall;
                if (actualAdditionalRaiseAmount < 0) {
                    showMessage("Error: Cannot raise, not enough chips to even call.", true);
                    actionHistory.pop(); return;
                }
            }

            const chipsToPutInPot = amountToCall + actualAdditionalRaiseAmount;
            player.stack -= chipsToPutInPot;
            player.betThisStreet += chipsToPutInPot;
            pot += chipsToPutInPot;

            actionTakenMessage += `raises by an additional ${actualAdditionalRaiseAmount} (total bet ${player.betThisStreet}).`;

            if (player.stack === 0) {
                player.isAllIn = true;
                actionTakenMessage += " (ALL-IN!)";
            }

            currentBetForStreet = player.betThisStreet;
            lastRaiseAmount = actualAdditionalRaiseAmount;
            minAdditionalRaise = actualAdditionalRaiseAmount;

            players.forEach((p, idx) => {
                if (idx !== currentPlayerIndex && !p.folded && !p.isAllIn) {
                    p.hasActedThisCycle = false;
                }
            });
        }
        showMessage(actionTakenMessage);
        raiseAmountInput.value = '';
        checkBettingRoundEnd();
    }

    function checkBettingRoundEnd() {
        const potentiallyActive = getPotentiallyActivePlayers();

        if (potentiallyActive.length <= 1) {
            const activeInHand = getActivePlayers();
            if (activeInHand.length <= 1) {
                updateUI();
                setTimeout(() => awardPotToWinner(activeInHand.length === 1 ? activeInHand[0] : null), 500);
                return;
            }
            if ( (potentiallyActive.length === 1 && potentiallyActive[0].hasActedThisCycle && potentiallyActive[0].betThisStreet >= currentBetForStreet) ||
                 (potentiallyActive.length === 0 && activeInHand.length > 1) ) {
                advanceGamePhase(); return;
            }
        }

        let allEligibleActedAndMatched = true;
        for (const player of players) {
            if (!player.folded && !player.isAllIn) {
                if (!player.hasActedThisCycle || player.betThisStreet < currentBetForStreet) {
                    allEligibleActedAndMatched = false;
                    break;
                }
            }
        }

        const bbIndex = getBBIndex();
        const isPreflopBBTurnAndOption = gamePhase === 'preflop' &&
                                      players[currentPlayerIndex] &&
                                      currentPlayerIndex === bbIndex &&
                                      !players[currentPlayerIndex].hasActedThisCycle &&
                                      currentBetForStreet === bigBlindValue;

        if (allEligibleActedAndMatched && !isPreflopBBTurnAndOption) {
            advanceGamePhase(); return;
        }

        moveToNextPlayer();
        updateUI();
    }

    function getBBIndex() {
        const activePlayerIndices = players.map((p, i) => p.stack > 0 ? i : -1).filter(i => i !== -1);
        if (activePlayerIndices.length < 2) return -1;

        let currentDealerActualIndex = dealerIndex;
        let dealerPosInActive = activePlayerIndices.indexOf(currentDealerActualIndex);
         if(dealerPosInActive === -1 && activePlayerIndices.length > 0) dealerPosInActive = 0;

        if (activePlayerIndices.length === 2) return activePlayerIndices[(dealerPosInActive + 1) % activePlayerIndices.length];
        return activePlayerIndices[(dealerPosInActive + 2) % activePlayerIndices.length];
    }


    function moveToNextPlayer() {
        let initialCheckIndex = currentPlayerIndex;
        let nextPlayerIdx = (currentPlayerIndex + 1) % players.length;

        while (true) {
            const p = players[nextPlayerIdx];
            if (!p.folded && !p.isAllIn) {
                currentPlayerIndex = nextPlayerIdx;
                return;
            }
            nextPlayerIdx = (nextPlayerIdx + 1) % players.length;
            if (nextPlayerIdx === initialCheckIndex) {
                console.warn("moveToNextPlayer cycled: betting round should have ended.");
                return;
            }
        }
    }

    function advanceGamePhase() {
        players.forEach(p => {
            p.hasActedThisCycle = false;
        });
        currentBetForStreet = 0;
        minAdditionalRaise = bigBlindValue;
        lastRaiseAmount = bigBlindValue;

        const oldPhase = gamePhase;
        if (oldPhase === 'preflop') {
            gamePhase = 'flop';
            communityCardsRevealed[0] = true; communityCardsRevealed[1] = true; communityCardsRevealed[2] = true;
        } else if (oldPhase === 'flop') {
            gamePhase = 'turn';
            communityCardsRevealed[3] = true;
        } else if (oldPhase === 'turn') {
            gamePhase = 'river';
            communityCardsRevealed[4] = true;
        } else if (oldPhase === 'river') {
            gamePhase = 'showdown';
        } else {
             console.error("Unknown game phase to advance from:", oldPhase); return;
        }

        if (gamePhase === 'showdown') {
            handleShowdown(); updateUI(); return;
        }

        showMessage(`${gamePhase.charAt(0).toUpperCase() + gamePhase.slice(1)} comes. Betting starts.`);

        currentPlayerIndex = (dealerIndex + 1) % players.length;
        let count = 0;
        let foundNextPlayer = false;
        while (count < players.length * 2) {
            if (!players[currentPlayerIndex].folded && !players[currentPlayerIndex].isAllIn) {
                foundNextPlayer = true;
                break;
            }
            currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
            count++;
        }

        const activeForBetting = getPotentiallyActivePlayers();
        if (!foundNextPlayer || activeForBetting.length === 0) {
             if (gamePhase !== 'river') {
                advanceGamePhase();
             } else {
                gamePhase = 'showdown';
                handleShowdown();
             }
             updateUI(); return;
        }

        saveStateForUndo();
        updateUI();
    }

    function handleShowdown() {
        showMessage("Showdown! Determine the winner(s).");
        if (!communityCardsRevealed[0]) communityCardsRevealed[0] = communityCardsRevealed[1] = communityCardsRevealed[2] = true;
        if (!communityCardsRevealed[3]) communityCardsRevealed[3] = true;
        if (!communityCardsRevealed[4]) communityCardsRevealed[4] = true;

        const contenders = players.filter(p => !p.folded);
        if (contenders.length === 0) {
            showMessage("Error: No contenders in showdown.", true);
            gamePhase = 'roundEnd'; messageArea.textContent += " Press 'N' for Next Round."; updateUI(); return;
        }
        if (contenders.length === 1) {
            awardPotToWinner(contenders[0]);
        } else {
            winnerSelectionModal.classList.remove('hidden');
            winnerOptionsContainer.innerHTML = '';
            contenders.forEach(player => {
                const actualIndex = players.findIndex(p => p.name === player.name && p.stack === player.stack);
                const btn = document.createElement('button');
                btn.className = 'block w-full text-left p-2.5 bg-blue-600 hover:bg-blue-700 rounded-md mb-1.5 action-button text-sm';
                btn.textContent = player.name;
                btn.onclick = () => {
                    winnerSelectionModal.classList.add('hidden');
                    awardPotToWinner(players[actualIndex]);
                };
                winnerOptionsContainer.appendChild(btn);
            });
        }
        updateUI();
    }

    cancelWinnerSelectionBtn.onclick = () => {
        winnerSelectionModal.classList.add('hidden');
        showMessage("Showdown winner selection cancelled. Resolve manually or declare again.");
    };

    function awardPotToWinner(winner) {
        if (winner) {
            winner.stack += pot;
            showMessage(`${winner.name} wins ${pot} chips! Press 'N' for Next Round.`);
        } else {
            const activeNonFolded = players.filter(p => !p.folded);
            if (activeNonFolded.length === 1) {
                activeNonFolded[0].stack += pot;
                showMessage(`${activeNonFolded[0].name} wins ${pot} (last one)! Press 'N' for Next Round.`);
            } else {
                showMessage(`Pot of ${pot} is split/unawarded. Press 'N' for Next Round.`);
            }
        }
        pot = 0;
        players.forEach(p => p.betThisStreet = 0);
        gamePhase = 'roundEnd';
        saveStateForUndo();
        updateUI();
    }

    function handleWinnerSelection(winnerIndex) {
        const winner = players[winnerIndex];
        awardPotToWinner(winner);
    }

    function endGame() {
        showMessage("Game Over. Not enough players with chips.", true);
        gamePhase = 'gameOver';
        const actionsAndPromptContainer = document.getElementById('actions-and-prompt-container');
        if (actionsAndPromptContainer) actionsAndPromptContainer.classList.add('hidden');
        undoBtn.disabled = true;

        const newGameBtn = document.createElement('button');
        newGameBtn.textContent = 'Start New Game Setup';
        newGameBtn.className = 'action-button bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg mt-4';
        newGameBtn.onclick = () => {
            gameBoard.classList.add('hidden');
            setupSection.classList.remove('hidden');
            players = []; pot = 0; dealerIndex = -1; actionHistory = [];
            communityCardsRevealed = [false,false,false,false,false];
        };
        if (messageArea) { // Ensure messageArea is clear before appending new game button
            messageArea.innerHTML = ''; // Clear previous messages
            messageArea.appendChild(newGameBtn); // Append button to message area
        }
        updateUI(); // Update UI to reflect game over state
    }


    // --- Event Listeners ---
    foldBtn.addEventListener('click', () => handleAction('fold'));
    callCheckBtn.addEventListener('click', () => handleAction('call-check'));
    raiseBtn.addEventListener('click', () => {
        const additionalAmount = parseInt(raiseAmountInput.value);
        if (isNaN(additionalAmount) || additionalAmount <= 0) {
            showMessage("Please enter a valid positive amount to raise BY.", true); return;
        }

        const player = players[currentPlayerIndex];
        const amountToCall = Math.max(0, currentBetForStreet - player.betThisStreet);
        const totalChipsNeededForAction = amountToCall + additionalAmount;

        if (additionalAmount < minAdditionalRaise && player.stack > totalChipsNeededForAction) {
            showMessage(`Min additional raise is ${minAdditionalRaise}. You tried to add ${additionalAmount}.`, true);
            return;
        }
        if (player.stack <= totalChipsNeededForAction) {
            const allInAdditionalAmount = player.stack - amountToCall;
            if (allInAdditionalAmount <= 0 && amountToCall > 0 && currentBetForStreet > 0) {
                 showMessage("All-in amount is not enough to constitute a raise over the current bet. Call or Fold.", true);
                 return;
            }
        }
        handleAction('raise', additionalAmount);
    });

    raiseAmountInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            if (!raiseBtn.disabled) raiseBtn.click();
        }
    });

    undoBtn.addEventListener('click', loadStateFromUndo);

    manualEditToggleBtn.addEventListener('click', () => {
        manualEditMode = !manualEditMode;
        manualEditToggleBtn.textContent = manualEditMode ? 'Done Edit' : 'Edit Stacks';
        manualEditToggleBtn.classList.toggle('bg-purple-600', !manualEditMode);
        manualEditToggleBtn.classList.toggle('hover:bg-purple-700', !manualEditMode);
        manualEditToggleBtn.classList.toggle('bg-red-500', manualEditMode);
        manualEditToggleBtn.classList.toggle('hover:bg-red-600', manualEditMode);
        updateUI();
    });

    document.addEventListener('keydown', (e) => {
        const isSetupVisible = setupSection.offsetParent !== null;
        const isPlayerNamesVisible = playerNamesSection.offsetParent !== null;
        const isModalVisible = winnerSelectionModal.offsetParent !== null;

        if (isSetupVisible || isPlayerNamesVisible || isModalVisible) return;

        const activeEl = document.activeElement;
        const isTypingInInput = activeEl.tagName === 'INPUT' && (activeEl.type === 'text' || activeEl.type === 'number');

        if (e.key.toUpperCase() === 'N' && gamePhase === 'roundEnd') {
            startNewRound();
        } else if (gamePhase !== 'roundEnd' && gamePhase !== 'showdown' && gamePhase !== 'gameOver') {
            if (e.key.toUpperCase() === 'F' && !isTypingInInput) {
                if (!foldBtn.disabled) { e.preventDefault(); foldBtn.click(); }
            } else if (e.key.toUpperCase() === 'C' && !isTypingInInput) {
                if (!callCheckBtn.disabled) { e.preventDefault(); callCheckBtn.click(); }
            } else if (e.key.toUpperCase() === 'U' && !isTypingInInput) {
                 if (!undoBtn.disabled) { e.preventDefault(); undoBtn.click(); }
            } else if (/\d/.test(e.key) && activeEl !== raiseAmountInput && !isTypingInInput) {
                if (!raiseAmountInput.disabled) {
                    e.preventDefault();
                    if (raiseAmountInput.value === '' && e.key === '0') return;
                    raiseAmountInput.value += e.key;
                    raiseAmountInput.focus();
                }
            }
        }
    });

    // Initial setup visibility
    playerNamesSection.classList.add('hidden');
    gameBoard.classList.add('hidden');
    winnerSelectionModal.classList.add('hidden');

</script>
</body>
</html>
